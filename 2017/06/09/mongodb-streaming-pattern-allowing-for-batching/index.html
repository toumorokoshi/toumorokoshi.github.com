<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>MongoDB Streaming Pattern, Allowing for Batching | Yusuke Tsutsumi</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="MongoDB Streaming Pattern, Allowing for Batching" />
<meta name="author" content="toumorokoshi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An interesting problem arose at work today, regarding how to build an aggregate of changes to a MongoDB collection." />
<meta property="og:description" content="An interesting problem arose at work today, regarding how to build an aggregate of changes to a MongoDB collection." />
<link rel="canonical" href="https://y.tsutsumi.io/2017/06/09/mongodb-streaming-pattern-allowing-for-batching/" />
<meta property="og:url" content="https://y.tsutsumi.io/2017/06/09/mongodb-streaming-pattern-allowing-for-batching/" />
<meta property="og:site_name" content="Yusuke Tsutsumi" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-09T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="MongoDB Streaming Pattern, Allowing for Batching" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"toumorokoshi"},"dateModified":"2017-06-09T00:00:00+00:00","datePublished":"2017-06-09T00:00:00+00:00","description":"An interesting problem arose at work today, regarding how to build an aggregate of changes to a MongoDB collection.","headline":"MongoDB Streaming Pattern, Allowing for Batching","mainEntityOfPage":{"@type":"WebPage","@id":"https://y.tsutsumi.io/2017/06/09/mongodb-streaming-pattern-allowing-for-batching/"},"url":"https://y.tsutsumi.io/2017/06/09/mongodb-streaming-pattern-allowing-for-batching/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://y.tsutsumi.io/feed/index.xml" title="Yusuke Tsutsumi" />
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-29270527-2', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', true);
    </script>
    <!-- End Google Analytics -->
    </head>
<body><header class="site-header">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Yusuke Tsutsumi</a><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger" />
            <label for="nav-trigger">
                <span class="menu-icon">
                    <svg viewBox="0 0 18 15" width="18px" height="15px">
                        <path
                            d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
                    </svg>
                </span>
            </label>

            <div class="trigger">
                <a class="page-link" href="/tag/coding/">Coding Posts</a>
                <a class="page-link"
                    href="https://nbviewer.jupyter.org/github/toumorokoshi/notebooks/tree/master/">Notebooks</a><a class="page-link" href="/resources/">Resources</a><a class="page-link" href="/about/">About Yusuke Tsutsumi</a></div>
        </nav></div>
    <style>
        .gse-control-cse td {
            border: 0;
        }

        td.gsc-input {
            border: 0;
        }

        td.gsc-search-button {
            border: 0;
        }

        table.gsc-input {
            margin-bottom: 0;
        }
    </style>
</header><main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">MongoDB Streaming Pattern, Allowing for Batching</h1>
        <p class="post-meta"><time class="dt-published" datetime="2017-06-09T00:00:00+00:00" itemprop="datePublished">
                Jun 9, 2017
            </time>â€¢ 
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
                <span class="p-author h-card" itemprop="name">toumorokoshi</span></span></p>
    </header>

    <div class="post-content e-content" itemprop="articleBody">
        <p>An interesting problem arose at work today, regarding how to build an
aggregate of changes to a MongoDB collection.</p>

<p>A more general version of the problem is:</p>

<ol>
  <li>
    <p>you have a document which has multiple buckets it could belong to.
Say, an animal which an arbitrary set of tags, such as ["mammal",
"wings"], and a discrete type location ["backyard",
"frontyard", "house"].</p>

    <p>an example document could look like:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ "name": "Cat",
  "location": "house",
  "tags": ["mammal", "ears"]
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Make it easy to retrieve the sum of each type, by tag. So:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "tag": "mammal",
   "location": {
     "house": 10,
     "backyard": 4,
     "frontyard": 2,
   }
}
</code></pre></div>    </div>
  </li>
</ol>

<p>The animal location is updated regularly, so the aggregates can change
over time.</p>
                <h2 id="a-first-attempt">   A First Attempt <a href="#a-first-attempt">#</a>   </h2>
                    

<p>The simplest way to perform this is to rely on Mongo to retrieve all
animals that match the tag by indexing the tag field, then handling the
query and count in the application.</p>

<p>This works well for small scales. However, performing the action in this
way requires a scanning query per aggregate, and that must scan every
document returned to perform the aggregate. So, O(matched_documents):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">return_count_by_tag</span><span class="p">(</span><span class="n">tag_name</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"tag"</span><span class="p">:</span> <span class="n">tag_name</span><span class="p">,</span>
        <span class="s">"location"</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">db</span><span class="p">.</span><span class="n">animals</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="s">"tag"</span><span class="p">:</span> <span class="n">tag_name</span><span class="p">},</span> <span class="p">{</span><span class="s">"location"</span><span class="p">:</span> <span class="mi">1</span><span class="p">}):</span>
        <span class="n">result</span><span class="p">[</span><span class="s">"type_count"</span><span class="p">][</span><span class="n">result</span><span class="p">[</span><span class="s">"location"</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>In our case, we needed to return an answer for every tag, within a
minute. We were able to scale the approach with this constraint in mind
to 35,000 tags and 120,000 documents. At that point, the application was
unable to build the aggregates fast enough.</p>
                <h2 id="the-new-strategy">   The New Strategy <a href="#the-new-strategy">#</a>   </h2>
                    

<p>The main disadvantage of the previous design is the calculation of the
aggregate counts does not need to be on read: if we can ensure
consistent count updates as the location actually changes per document,
we can perform O(tag_count) updates per document instead.</p>

<p>The comparative complexity over a minute is:</p>

<ul>
  <li>old: len(distinct_tags) * len(average_animals_per_tag)</li>
  <li>new: len(updates_per_minute) * len(average_tag_count_per_animal)</li>
</ul>

<p>So, if we have:</p>

<ul>
  <li>30,000 tags</li>
  <li>120,000 animals</li>
  <li>40 animals average per tag</li>
  <li>(40 * 30,000) / (120,000) = 10 tags per animal</li>
  <li>10000 updates a minute</li>
</ul>

<p>The number of documents touched is:</p>

<p>old: 30k * 40 = 1.2 million reads new: 10k * 10 = 100,000 writes</p>

<p>So, we can scale a bit better by handling writes over reads. This
becomes an even better ratio if the updates occur at a less frequent
cadence.</p>

<p>So, the stream processing works by:</p>

<ol>
  <li>every desired changes is enqueued into a queue (in Mongo, this can
be implemented as a capped collection)</li>
  <li>a worker process pulls from the queue, and processes the results.</li>
</ol>

<p>The worker process:</p>

<p>1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reads a watermark value of where it had processed

:   previously (Mongo ObjectIds increase relative to time and
    insertion order, so it can be used as the watermark)
</code></pre></div></div>

<ol>
  <li>
    <p>performs the work required</p>
  </li>
  <li>
    <p>saves works to the collection</p>
  </li>
  <li>
    <p>writes the watermark value of where it had finished processing.</p>
  </li>
</ol>

<p>You could also delete records as you process them, but it can cause
issues if you need to read a record again, or if multiple workers need
them. need them.</p>
                <h2 id="starting-from-scratch">   Starting from Scratch <a href="#starting-from-scratch">#</a>   </h2>
                    

<p>So how do we allow starting from scratch? Or, rebuilding the aggregates
if an issue occurs?</p>

<p>There could be a function that performs the whole collection
calculation, dumps it to the collection, and sets the watermark to
whatever the most recent object is in the queue.</p>

<p>Unfortunately, this process and the worker process cannot run at the
same time. If that happens, then the aggregate collection will be
corrupted, as one could query an older version of the collection, have
updates that are applied to the original aggregate copy, and are
overwritten with a stale copy from the rebuild.</p>

<p>Thus, we must ensure that the update worker does not run at the same
time as the batch worker.</p>
                <h2 id="a-locking-strategy">   A locking strategy <a href="#a-locking-strategy">#</a>   </h2>
                    

<p>In Mongo, the locking is decided by the database, and a user has no
control over that. Thus, we must implement our own locking functionality
by using Mongo primitives.</p>

<p>The same record that holds the watermark could also hold the lock. To
ensure that we can survive a worker dying halfway and not releasing, the
lock, we can provide a lock owner, ensuring the same process type can
begin an operation again:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"pet-aggregates"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"watermark: ObjectId("</span><span class="err">DEADBEEF</span><span class="s2">"),
  "</span><span class="err">lock</span><span class="s2">": {
      "</span><span class="err">type</span><span class="s2">": "</span><span class="err">update</span><span class="s2">" // could also be type: bulk
  }
}
</span></code></pre></div></div>

<p>Using this type of lock, the possible failure scenarios are:</p>

<p>1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>update process lock, failure, and update doesn\'t run again:

:   This requires manually looking at the issue, resolving, and
    restarting the queue.
</code></pre></div></div>

<p>2.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bulk process lock, failure, and bulk doesn\'t run again:

:   This requires manually looking at the issue, resolving, and
    restarting the queue.
</code></pre></div></div>
    </div><a class="u-url" href="/2017/06/09/mongodb-streaming-pattern-allowing-for-batching/" hidden></a>
</article>
        </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/%20/"></data>

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <script async src="https://cse.google.com/cse.js?cx=014358564571565173111:hnnbq4j54cy"></script>
            <div class="gcse-search"></div>
        </div>
        <div class="footer-col-wrapper">
            <div class="footer-col">
                <p class="feed-subscribe">
                    <a href="/feed/index.xml">
                        <svg class="svg-icon orange">
                            <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
                        </svg><span>Subscribe</span>
                    </a>
                </p>
            </div>
            <div class="footer-col">
                <p>My blog on software, productivity, and obsessively optimizing. I work at Google, ex-Zillow. Thoughts my own.</p>
            </div>
        </div>

        <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/toumorokoshi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">toumorokoshi</span></a></li><li><a href="https://www.twitter.com/tsutsumiyusuke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">tsutsumiyusuke</span></a></li></ul>
</div>

    </div>

</footer></body>

</html>