<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Seven Languages in Seven Weeks: Haskell Day 3 | Yusuke Tsutsumi</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Seven Languages in Seven Weeks: Haskell Day 3" />
<meta name="author" content="toumorokoshi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A few months ago, I tried my hand at Seven Languages in Seven Weeks, and it was an incredibly enlightening experience." />
<meta property="og:description" content="A few months ago, I tried my hand at Seven Languages in Seven Weeks, and it was an incredibly enlightening experience." />
<link rel="canonical" href="https://y.tsutsumi.io/2014/03/28/seven-languages-in-seven-weeks-haskell-day-3/" />
<meta property="og:url" content="https://y.tsutsumi.io/2014/03/28/seven-languages-in-seven-weeks-haskell-day-3/" />
<meta property="og:site_name" content="Yusuke Tsutsumi" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-03-28T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Seven Languages in Seven Weeks: Haskell Day 3" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"toumorokoshi"},"dateModified":"2014-03-28T00:00:00+00:00","datePublished":"2014-03-28T00:00:00+00:00","description":"A few months ago, I tried my hand at Seven Languages in Seven Weeks, and it was an incredibly enlightening experience.","headline":"Seven Languages in Seven Weeks: Haskell Day 3","mainEntityOfPage":{"@type":"WebPage","@id":"https://y.tsutsumi.io/2014/03/28/seven-languages-in-seven-weeks-haskell-day-3/"},"url":"https://y.tsutsumi.io/2014/03/28/seven-languages-in-seven-weeks-haskell-day-3/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://y.tsutsumi.io/feed/index.xml" title="Yusuke Tsutsumi" />
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-29270527-2', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', true);
    </script>
    <!-- End Google Analytics -->
    </head>
<body><header class="site-header">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Yusuke Tsutsumi</a><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger" />
            <label for="nav-trigger">
                <span class="menu-icon">
                    <svg viewBox="0 0 18 15" width="18px" height="15px">
                        <path
                            d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
                    </svg>
                </span>
            </label>

            <div class="trigger">
                <a class="page-link" href="/tag/coding/">Coding Posts</a>
                <a class="page-link"
                    href="https://nbviewer.jupyter.org/github/toumorokoshi/notebooks/tree/master/">Notebooks</a><a class="page-link" href="/resources/">Resources</a><a class="page-link" href="/about/">About Yusuke Tsutsumi</a></div>
        </nav></div>
    <style>
        .gse-control-cse td {
            border: 0;
        }

        td.gsc-input {
            border: 0;
        }

        td.gsc-search-button {
            border: 0;
        }

        table.gsc-input {
            margin-bottom: 0;
        }
    </style>
</header><main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">Seven Languages in Seven Weeks: Haskell Day 3</h1>
        <p class="post-meta"><time class="dt-published" datetime="2014-03-28T00:00:00+00:00" itemprop="datePublished">
                Mar 28, 2014
            </time>• 
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
                <span class="p-author h-card" itemprop="name">toumorokoshi</span></span></p>
    </header>

    <div class="post-content e-content" itemprop="articleBody">
        <p>A few months ago, I tried my hand at <a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks">Seven Languages in Seven Weeks</a>,
and it was an incredibly enlightening experience.</p>

<p>There was one excersize that kept me at odds for weeks though, so I
thought I’d share my experience.</p>
                <h2 id="haskell-day-3-creating-and-writing-a-maze-solver">   Haskell Day 3: Creating and writing a Maze Solver <a href="#haskell-day-3-creating-and-writing-a-maze-solver">#</a>   </h2>
                    

<p>The excersize calls for accomplishing two tasks:</p>

<ul>
  <li>
    <p>Creating a data structure for storing a maze</p>
  </li>
  <li>
    <p>Write a method to solve it</p>
  </li>
</ul>

<p>I think there’s a few ways to organize the data, but I chose a format that was fairly readable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data Exits = North | West | East | South deriving (Show, Eq)
data Node = NodePath (Int, Int) [Exits] | TerminalNode (Int, Int) deriving (Show, Eq)
type Maze = [[Node]]
testMaze :: Maze
testMaze = [
 [ (NodePath (0,0) [South]), (NodePath (1, 0) []), (NodePath (2, 0) []) ],
 [ (NodePath (0,1) [East]), (NodePath (1, 1) [East]), (NodePath (2, 1) [North, South]) ],
 [ (NodePath (0,2) []), (NodePath (1, 2) []), (TerminalNode (2, 2)) ]
       ]
</code></pre></div></div>

<p>Basically, this creates a few types:</p>

<ul>
  <li>
    <p>Exits, to deal with the directions from which one can move from the current position</p>
  </li>
  <li>
    <p>Node, which consists of nodes with paths (a NodePath), and a Final node (TerminalNode).</p>
  </li>
  <li>
    <p>Maze, which is simply a two-dimensional array of nodes.</p>
  </li>
</ul>

<p>I think there’s liberties here as well, but I wanted to note my choice
a NodePath and TerminalNode type: it seemed like creating completely
different types altogether allowed me to rely on the strict type of
Haskell better to solve my problems, instead of emebedding logic. But YRMV.</p>

<p>One big downside: putting data in structures like this made it hard to
get the data I want, and also rely on the typing. Ultimately I had to
create several utility methods to help me:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- getNode: Returns a node object given a maze and a position
    getNode :: Maze -&gt; (Int, Int)-&gt; Node
    getNode maze (x,y) = maze !! y !! x
-- getExits: return all the exits for a node
    getExits :: Node -&gt; [Exits]
    getExits (NodePath _ exits) = exits
    getExits (TerminalNode _) = []
-- getPosition: return a (x,y) of the position of a node
    getPosition :: Node -&gt; (Int, Int)
    getPosition (NodePath (x,y) _) = (x, y)
    getPosition (TerminalNode (x,y)) = (x, y)
</code></pre></div></div>

<p>I definitely must be doing something wrong here. The rigid typing of
Haskell should allow me to take advantage of the inner data without
creating accessors like this. But I’m not a Haskell expert, so I made
do with what I understood.</p>

<p>Finally, I have all the tools I need to write my solver. Here it is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- getNextNode: given a node, maze, and an exit, return the next node from the maze
    getNextNode :: Node -&gt; Maze -&gt; Exits -&gt; Node
    getNextNode node maze exit =
        let (x, y) = getPosition node
        in
          case exit of
            North -&gt; getNode maze (x, y - 1)
            West -&gt; getNode maze (x - 1, y)
            East -&gt; getNode maze (x + 1, y)
            South -&gt; getNode maze (x, y + 1)
-- If the element already exists in the path, we're at a dead end.
-- solveRoute: returns a list of the valid routes to the exit
    solveRoute :: Maze -&gt; Node -&gt; [Node] -&gt; Exits -&gt; Maybe [Node]
    solveRoute maze node path exit =
        let nextNode = getNextNode node maze exit
        in
          if (nextNode `elem` path)
          then
              Nothing
          else
              solveMaze maze nextNode (node:path)
-- solveMaze: solve the maze by taking solveRoute, filtering the successful results, and taking the first one.
    solveMaze :: Maze -&gt; Node -&gt; [Node] -&gt; Maybe [Node]
    solveMaze maze node path =
        case node of
          TerminalNode _ -&gt; Just (node:path)
          NodePath _ _-&gt;
                   let nodes = (filter (\x -&gt; x /= Nothing) (map (solveRoute maze node path) (getExits node)))
                   in
                     if (length nodes &gt; 0)
                     then
                         head nodes
                     else
                        Nothing
</code></pre></div></div>

<p>This code probably seems a bit contrived. Basically here’s what solveMaze does:</p>

<ul>
  <li>
    <p>delegates the logic to solveRoute if the node isn’t a terminalNode</p>
  </li>
  <li>
    <p>solveRoute gets the exits for the node. it loops through them, takes
the valid ones (the ones where the same position isn’t in there
twice), and passes them back into solveMaze</p>
  </li>
</ul>

<p>So solveMaze and solveRoute call each other until they find a valid
solution. I could have added them into the same method, but this
seemed like a logical split that made the code a little easier to understand.</p>

<p>This works. Give it a try:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mazeStart = getNode testMaze (0, 0)
mazeSolution = solveMaze testMaze mazeStart []
</code></pre></div></div>

<p>One of the big issues I have with solution, however, is the fact that
it doesn’t use a list monad in any way. And I’m still a bit confused
as to how it comes in handy here. From my understanding, a list monad
flattens a list of lists into a single list. So ultimately, my
solution might not be taking advantage of the real power of
Haskell. It is purely functional though, so maybe it is.</p>

<p>Here’s the code in full:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Day3 where
    import Data.List
    --    data Node = NodePath ((Int, Int), [Node]) | TerminalNode (Int, Int)
        data Exits = North | West | East | South deriving (Show, Eq)
        data Node = NodePath (Int, Int) [Exits] | TerminalNode (Int, Int) deriving (Show, Eq)
        type Maze = [[Node]]
        testMaze :: Maze
        testMaze = [
         [ (NodePath (0,0) [South]), (NodePath (1, 0) []), (NodePath (2, 0) []) ],
         [ (NodePath (0,1) [East]), (NodePath (1, 1) [East]), (NodePath (2, 1) [North, South]) ],
         [ (NodePath (0,2) []), (NodePath (1, 2) []), (TerminalNode (2, 2)) ]
               ]
    -- getNode
        getNode :: Maze -&gt; (Int, Int)-&gt; Node
        getNode maze (x,y) = maze !! y !! x
    -- getExists
        getExits :: Node -&gt; [Exits]
        getExits (NodePath _ exits) = exits
        getExits (TerminalNode _) = []
    -- getPosition
        getPosition :: Node -&gt; (Int, Int)
        getPosition (NodePath (x,y) _) = (x, y)
        getPosition (TerminalNode (x,y)) = (x, y)
    -- getNextNode
        getNextNode :: Node -&gt; Maze -&gt; Exits -&gt; Node
        getNextNode node maze exit =
            let (x, y) = getPosition node
            in
              case exit of
                North -&gt; getNode maze (x, y - 1)
                West -&gt; getNode maze (x - 1, y)
                East -&gt; getNode maze (x + 1, y)
                South -&gt; getNode maze (x, y + 1)
    -- If the element already exists in the path, we're at a dead end.
        solveRoute :: Maze -&gt; Node -&gt; [Node] -&gt; Exits -&gt; Maybe [Node]
        solveRoute maze node path exit =
            let nextNode = getNextNode node maze exit
            in
              if (nextNode `elem` path)
              then
                  Nothing
              else
                  solveMaze maze nextNode (node:path)
    -- solveMaze 2
        solveMaze :: Maze -&gt; Node -&gt; [Node] -&gt; Maybe [Node]
        solveMaze maze node path =
            case node of
              TerminalNode _ -&gt; Just (node:path)
              NodePath _ _-&gt;
                       let nodes = (filter (\x -&gt; x /= Nothing) (map (solveRoute maze node path) (getExits node)))
                       in
                         if (length nodes &gt; 0)
                         then
                             head nodes
                         else
                             Nothing
        mazeStart = getNode testMaze (0, 0)
        mazeSolution = solveMaze testMaze mazeStart []
</code></pre></div></div>
    </div><a class="u-url" href="/2014/03/28/seven-languages-in-seven-weeks-haskell-day-3/" hidden></a>
</article>
        </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/%20/"></data>

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <script async src="https://cse.google.com/cse.js?cx=014358564571565173111:hnnbq4j54cy"></script>
            <div class="gcse-search"></div>
        </div>
        <div class="footer-col-wrapper">
            <div class="footer-col">
                <p class="feed-subscribe">
                    <a href="/feed/index.xml">
                        <svg class="svg-icon orange">
                            <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
                        </svg><span>Subscribe</span>
                    </a>
                </p>
            </div>
            <div class="footer-col">
                <p>My blog on software, productivity, and obsessively optimizing. I work at Google, ex-Zillow. Thoughts my own.</p>
            </div>
        </div>

        <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/toumorokoshi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">toumorokoshi</span></a></li><li><a href="https://www.twitter.com/tsutsumiyusuke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">tsutsumiyusuke</span></a></li></ul>
</div>

    </div>

</footer></body>

</html>